## 📝숫자 변환하기
##### 알고리즘 구상
- 연산 3가지에 대해 최소 연산 횟수 -> 동적프로그래밍 사용
- x부터 y까지 n을 더하는 연산/2를 곱하는 연산/3을 곱하는 연산이 되는지 안되는지 확인하고 연산 및 전 연산횟수를 비교해서 +1
- y가 최대 1000000이라므로 이보다 큰 수는 y값으로 연산이 불가능

##### 참고 자료

##### 문제 풀이
- 크기 y+1의 벡터를 1000001으로 초기화
- 연산횟수 계산을 위해 DP[x]=0
- 현재 숫자에서 n을 뺄 수 있는 조건을 확인, 만약 가능하다면, 현재값과 (i-n 위치의 연산 횟수 + 1) 중 더 작은 값을 DP[i]에 저장
- 현재 숫자가 2로 나누어지고, 그 결과가 x 이상인 경우를 확인함. 가능하면 min으로 비교 및 연산횟수 업데이트
- 3으로 나누어지는 경우를 확인하고, 조건을 만족하면연산횟수 업데이트

---

## 📝귤 고르기
##### 알고리즘 구상
- 크기를 인덱스로 가지는 벡터에 개수 저장
- k개를 고를 때 특정 크기를 가지는 귤의 개수가 많은 것부터 쓸수록 귤의 종류는 적어질 것 -> 벡터 내림차순으로 정렬

##### 참고 자료
https://hipolarbear.tistory.com/11 

##### 문제 풀이
- 알고리즘 구상과 거의 동일

---

## 📝택배상자
##### 알고리즘 구상
- 택배상자 모두 같음, 1번상자부터 n번상자까지 번호 증가하는 순서대로 일렬로 영재에게 전달, 순서대로만 가능, 택배기사님한테 보내는 건 다시 실어야해서 보조컨테이너 존재. 앞뒤 이동 가능하지만 마지막에 넣은 것만 뺄 수 있음(스택) -> 택배기사가 알려준 순서대로 안되면 그대로 트럭에 실은 것까지만
- order[i]는 기존의 컨테이너 벨트에 order[i]번째 상자를 i+1번째로 트럭에 실어야 함을 의미합니다. -> 인덱스 0부터 하지말고 인덱스 1=첫번째 상자 로 생각
- 1번째부터 택배에 바로 싣을 수 있는지 없는지를 order의 첫 번째 요소부터 비교하며 확인 -> order의 요소와 다르면 스택에 넣고 같으면 트럭에 싣는 작업 반복

##### 참고 자료

##### 문제 풀이
- 알고리즘 구상과 거의 동일
